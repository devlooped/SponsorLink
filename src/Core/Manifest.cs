// <autogenerated />
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Security.Claims;
using System.Security.Cryptography;
using Microsoft.IdentityModel.JsonWebTokens;
using Microsoft.IdentityModel.Tokens;

namespace Devlooped.Sponsors;

/// <summary>
/// Validates manifests in JWT format.
/// </summary>
static partial class Manifest
{
    /// <summary>
    /// The resulting status from validation.
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// The manifest couldn't be read at all.
        /// </summary>
        Unknown,
        /// <summary>
        /// The manifest was read and is valid (not expired and properly signed).
        /// </summary>
        Valid,
        /// <summary>
        /// The manifest was read but has expired.
        /// </summary>
        Expired,
        /// <summary>
        /// The manifest was read, but its signature is invalid.
        /// </summary>
        Invalid,
    }

    /// <summary>
    /// Gets the expiration date from the principal, if any.
    /// </summary>
    /// <returns>
    /// Whichever "exp" claim is the latest, or <see langword="null"/> if none found.
    /// </returns>
    public static DateTime? GetExpiration(this ClaimsPrincipal principal)
        // get all "exp" claims, parse them and return the latest one or null if none found
        => principal.FindAll("exp")
            .Select(c => c.Value)
            .Select(long.Parse)
            .Select(DateTimeOffset.FromUnixTimeSeconds)
            .Max().DateTime is var exp && exp == DateTime.MinValue ? null : exp;

    /// <summary>
    /// Reads all manifests, validating their signatures.
    /// </summary>
    /// <param name="principal">The combined principal with all identities (and their claims) from each provided and valid JWT</param>
    /// <param name="values">The tokens to read and their corresponding JWK for signature verification.</param>
    /// <returns><see langword="true"/> if at least one manifest can be successfully read and is valid. 
    /// <see langword="false"/> otherwise.</returns>
    public static bool TryRead([NotNullWhen(true)] out ClaimsPrincipal? principal, IEnumerable<(string? jwt, string? jwk)> values)
    {
        principal = null;

        foreach (var value in values)
        {
            if (string.IsNullOrWhiteSpace(value.jwt) || string.IsNullOrWhiteSpace(value.jwk))
                continue;

            if (Validate(value.jwt!, value.jwk!, out var token, out var claims, false) == Status.Valid && claims != null)
            {
                if (principal == null)
                    principal = claims;
                else
                    principal.AddIdentities(claims.Identities);
            }
        }

        return principal != null;
    }

    /// <summary>
    /// Reads all manifests, validating their signatures.
    /// </summary>
    /// <param name="principal">The combined principal with all identities (and their claims) from each provided and valid JWT</param>
    /// <param name="values">The tokens to read and their corresponding security key for signature verification.</param>
    /// <returns><see langword="true"/> if at least one manifest can be successfully read and is valid. 
    /// <see langword="false"/> otherwise.</returns>
    public static bool TryRead([NotNullWhen(true)] out ClaimsPrincipal? principal, IEnumerable<(string? jwt, SecurityKey key)> values)
    {
        principal = null;

        foreach (var value in values)
        {
            if (string.IsNullOrWhiteSpace(value.jwt))
                continue;

            if (Validate(value.jwt!, value.key, out var token, out var claims, false) == Status.Valid && claims != null)
            {
                if (principal == null)
                    principal = claims;
                else
                    principal.AddIdentities(claims.Identities);
            }
        }

        return principal != null;
    }

    /// <summary>
    /// Reads all manifests, validating their signatures.
    /// </summary>
    /// <param name="principal">The combined principal with all identities (and their claims) from each provided and valid JWT</param>
    /// <param name="values">The tokens to read and their corresponding public key for signature verification.</param>
    /// <returns><see langword="true"/> if at least one manifest can be successfully read and is valid. 
    /// <see langword="false"/> otherwise.</returns>
    public static bool TryRead([NotNullWhen(true)] out ClaimsPrincipal? principal, params (string? jwt, string? jwk)[] values)
        => TryRead(out principal, values);

    /// <summary>
    /// Reads all manifests, validating their signatures.
    /// </summary>
    /// <param name="principal">The combined principal with all identities (and their claims) from each provided and valid JWT</param>
    /// <param name="values">The tokens to read and their corresponding security key for signature verification.</param>
    /// <returns><see langword="true"/> if at least one manifest can be successfully read and is valid. 
    /// <see langword="false"/> otherwise.</returns>
    public static bool TryRead([NotNullWhen(true)] out ClaimsPrincipal? principal, params (string? jwt, SecurityKey? jwk)[] values)
        => TryRead(out principal, values);

    /// <summary>
    /// Validates the manifest signature and optional expiration.
    /// </summary>
    /// <param name="jwt">The JWT to validate.</param>
    /// <param name="jwk">The JSON Web Key to validate the manifest signature with.</param>
    /// <param name="token">Except when returning <see cref="Status.Unknown"/>, returns the security token read from the JWT, even if signature check failed.</param>
    /// <param name="principal">The associated claims, only when return value is not <see cref="Status.Unknown"/>.</param>
    /// <param name="requireExpiration">Whether to check for expiration.</param>
    /// <returns>The status of the validation.</returns>
    public static Status Validate(string jwt, string jwk, out SecurityToken? token, out ClaimsPrincipal? principal, bool validateExpiration)
        => Validate(jwt, new JsonWebKey(jwk), out token, out principal, validateExpiration);

    /// <summary>
    /// Validates the manifest signature and optional expiration.
    /// </summary>
    /// <param name="jwt">The JWT to validate.</param>
    /// <param name="key">The key to validate the manifest signature with.</param>
    /// <param name="token">Except when returning <see cref="Status.Unknown"/>, returns the security token read from the JWT, even if signature check failed.</param>
    /// <param name="principal">The associated claims, only when return value is not <see cref="Status.Unknown"/>.</param>
    /// <param name="requireExpiration">Whether to check for expiration.</param>
    /// <returns>The status of the validation.</returns>
    public static Status Validate(string jwt, RSA key, out SecurityToken? token, out ClaimsPrincipal? principal, bool validateExpiration)
        => Validate(jwt, new RsaSecurityKey(key), out token, out principal, validateExpiration);

    /// <summary>
    /// Validates the manifest signature and optional expiration.
    /// </summary>
    /// <param name="jwt">The JWT to validate.</param>
    /// <param name="key">The key to validate the manifest signature with.</param>
    /// <param name="token">Except when returning <see cref="Status.Unknown"/>, returns the security token read from the JWT, even if signature check failed.</param>
    /// <param name="principal">The associated claims, only when return value is not <see cref="Status.Unknown"/>.</param>
    /// <param name="requireExpiration">Whether to check for expiration.</param>
    /// <returns>The status of the validation.</returns>
    public static Status Validate(string jwt, SecurityKey key, out SecurityToken? token, out ClaimsPrincipal? principal, bool validateExpiration)
    {
        token = default;
        principal = default;
        var handler = new JsonWebTokenHandler 
        { 
            MapInboundClaims = false, 
            SetDefaultTimesOnTokenCreation = false,
        };

        if (!handler.CanReadToken(jwt))
            return Status.Unknown;

        var validation = new TokenValidationParameters
        {
            RequireExpirationTime = false,
            ValidateLifetime = false,
            ValidateAudience = false,
            ValidateIssuer = false,
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = key,
            RoleClaimType = "roles",
            NameClaimType = "sub",
        };

        var result = handler.ValidateTokenAsync(jwt, validation).Result;
        if (result.Exception != null)
        {
            if (result.Exception is SecurityTokenInvalidSignatureException)
            {
                var jwtToken = handler.ReadJsonWebToken(jwt);
                token = jwtToken;
                principal = new ClaimsPrincipal(new ClaimsIdentity(jwtToken.Claims));
                return Status.Invalid;
            }
            else
            {
                var jwtToken = handler.ReadJsonWebToken(jwt);
                token = jwtToken;
                principal = new ClaimsPrincipal(new ClaimsIdentity(jwtToken.Claims));
                return Status.Invalid;
            }
        }

        principal = new ClaimsPrincipal(result.ClaimsIdentity);
        token = result.SecurityToken;

        if (validateExpiration && token.ValidTo == DateTime.MinValue)
            return Status.Invalid;

        // The sponsorable manifest does not have an expiration time.
        if (validateExpiration && token.ValidTo < DateTimeOffset.UtcNow)
            return Status.Expired;

        return Status.Valid;
    }
}
